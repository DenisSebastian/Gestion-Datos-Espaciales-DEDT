<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Gestión de Datos Espaciales - 4&nbsp; Inferencia Espacial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./construccion_inds.html" rel="next">
<link href="./analisis_esp.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/style.css">
</head>

<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./inferencia.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Inferencia Espacial</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Gestión de Datos Espaciales</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Syllabus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro_inds.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Introducción a Indicadores Territoriales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./analisis_esp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Análisis Espacial</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./inferencia.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Inferencia Espacial</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./construccion_inds.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Construcción de Indicadores Territoriales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro_r.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introducción a R Project</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./variables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Variables en R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./funciones.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Funciones en R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dataframes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Dataframes en R</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./datos_espaciales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Datos Espaciales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./indicadores.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Indicadores Territoriales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./recursos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Instalación de Recursos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./control_r.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Estructuras en R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tidyverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Tidyverse en R</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenidos</h2>
   
  <ul>
  <li><a href="#objetivos-del-módulo" id="toc-objetivos-del-módulo" class="nav-link active" data-scroll-target="#objetivos-del-módulo"><span class="header-section-number">4.1</span> Objetivos del Módulo</a></li>
  <li><a href="#kernel-density-estimation" id="toc-kernel-density-estimation" class="nav-link" data-scroll-target="#kernel-density-estimation"><span class="header-section-number">4.2</span> Kernel Density Estimation</a>
  <ul class="collapse">
  <li><a href="#introducción" id="toc-introducción" class="nav-link" data-scroll-target="#introducción"><span class="header-section-number">4.2.1</span> Introducción</a></li>
  <li><a href="#conceptos-relacionados-kde-en-general" id="toc-conceptos-relacionados-kde-en-general" class="nav-link" data-scroll-target="#conceptos-relacionados-kde-en-general"><span class="header-section-number">4.2.2</span> Conceptos relacionados KDE en general</a></li>
  <li><a href="#kde-aproximación-espacial" id="toc-kde-aproximación-espacial" class="nav-link" data-scroll-target="#kde-aproximación-espacial"><span class="header-section-number">4.2.3</span> KDE aproximación espacial</a></li>
  </ul></li>
  <li><a href="#interpolación-inverso-a-distancia-ponderada-idw" id="toc-interpolación-inverso-a-distancia-ponderada-idw" class="nav-link" data-scroll-target="#interpolación-inverso-a-distancia-ponderada-idw"><span class="header-section-number">4.3</span> Interpolación Inverso a Distancia Ponderada IDW</a>
  <ul class="collapse">
  <li><a href="#definiciones" id="toc-definiciones" class="nav-link" data-scroll-target="#definiciones"><span class="header-section-number">4.3.1</span> Definiciones</a></li>
  </ul></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><span class="header-section-number">4.4</span> Referencias</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Inferencia Espacial</span></h1>
<p class="subtitle lead">KDE y IDW</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="objetivos-del-módulo" class="level2 page-columns page-full" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="objetivos-del-módulo"><span class="header-section-number">4.1</span> Objetivos del Módulo</h2>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/inferencia.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Objetivos del Módulo</figcaption>
</figure>
</div>
<ul>
<li>Conocer los fundamentos teóricos básicos de la inferencia espacial</li>
<li>Introducción de Kernel Density Estimation (KDE)</li>
<li>Introducción de Interpolación Inverso a la Distancia ponderada (IDW)</li>
</ul>
</section>
<section id="kernel-density-estimation" class="level2 page-columns page-full" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="kernel-density-estimation"><span class="header-section-number">4.2</span> Kernel Density Estimation</h2>
<section id="introducción" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="introducción"><span class="header-section-number">4.2.1</span> Introducción</h3>
<p>Identificar el tipo de distribución que tiene a una variable es un paso fundamental en prácticamente todos los estudios que implican datos, son muchas las ventajas que tiene disponer de una función que describa aproximadamente los datos. Por ejemplo, se puede calcular la probabilidad (o densidad en el caso de variables aleatorias continuas) de que una observación tome un determinado valor. También es posible simular nuevos. valores.</p>
<p>En términos generales, ajustar una distribución consiste en <strong>encontrar una función matemática capaz de describir un conjunto de datos</strong>. De entre todas las posibles funciones candidatas, lo interesante es encontrar aquella que, con mayor probabilidad, puede haber generado los datos observados.</p>
<p>Una de las aproximaciones más prácticas es utilizar como candidatas distribuciones paramétricas, estas son distribuciones conocidas cuyo comportamiento está determinado usando un número finito de parámetros. Por ejemplo, la distribución normal está parametrizada por la media y la desviación típica.</p>
<p>Cuando ninguna de las distribuciones paramétricas disponibles describe correctamente los datos, es necesario recurrir lo que se conoce como métodos de ajuste no paramétricos, cuyo objetivo es encontrar funciones que describan distribuciones cualesquiera, entendiendo por cualesquiera a que no se limitan a las distribuciones paramétricas conocidas. Uno de los métodos más empleados es kernel density estimation (KDE).</p>
</section>
<section id="conceptos-relacionados-kde-en-general" class="level3 page-columns page-full" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="conceptos-relacionados-kde-en-general"><span class="header-section-number">4.2.2</span> Conceptos relacionados KDE en general</h3>
<p>En estadística, kernel density estimation (KDE), es un método no paramétrico que permite estimar la función de densidad de probabilidad de una variable aleatoria a partir de un número finito de observaciones (muestra). Fué propuesto por Fix y Hodges (1951) y Rosenblatt (1956).</p>
<p>Una forma de entender cómo funciona un kernel density estimation (KDE) es partiendo del histograma. El histograma es una de las formas más utilizadas en estadística para representar la distribución de datos unidimensionales.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/histogram_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Histograma de una variable aleatoria bimodal</figcaption>
</figure>
</div>
<p>El Kernel density estimation (KDE) expande la idea del histograma, “cada observación aumenta la densidad de probabilidad en la zona donde se encuentra”, pero lo hace de forma que las contribuciones se agrupen creando una curva continua y suave (smooth).</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/obs_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Observaciones y sus posiciones ordenadas</figcaption>
</figure>
</div>
<p>A continuación, sobre cada observación se centra una distribución normal, con media igual al valor de la observación y desviación típica de 1 (más adelante se detalla la elección de este valor).</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/dist_normales_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Distribución normal por cada observaciones con media igual valor y desviación estándar = 1</figcaption>
</figure>
</div>
<p>De esta forma se consigue que cada observación contribuya justo en la posición que ocupa pero también, de forma gradual, en las regiones cercanas.</p>
<p>Por último, si se suman las contribuciones individuales y se dividen por el total de curvas (observaciones), se consigue una curva final que describe la distribución de las observaciones.sy</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/sum_distr_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Suma de las Distribuciones</figcaption>
</figure>
</div>
<p>En esta idea se fundamenta el método kernel density estimation (KDE): aproximar una función de densidad como la suma de funciones (kernel) de cada observación.</p>
<p><strong>Definición matemática</strong></p>
<p>Dado un conjunto de datos <span class="math inline">x={x_1,x_2,...,x_n}</span> la función de distribución de densidad <span class="math inline">f(x)</span> puede aproximarse utilizando un kernel density estimation (KDE) tal que:</p>
<p><span class="math display">
\hat{f}(x)=\frac{1}{n}\sum_{i = 1}^{n}K_h(x-x_i)= \frac{1}{nh}\sum_{i = 1}^{n}K\left(\frac{x-x_i}{h}\right)
</span> * <span class="math inline">n</span>: es el número de datos (observaciones). Cada uno de ellos es el centro sobre el que se coloca un kernel.</p>
<ul>
<li><p><span class="math inline">h</span>: es el ancho de banda (bandwidth o smoothing parameter). Controla cuánto se expande la influencia de cada observación. Si se emplea como kernel una distribución normal, equivale a la desviación típica. Este es el valor más determinante a la hora de ajustar un KDE, puesto que condiciona el nivel de sobreajuste.</p></li>
<li><p><span class="math inline">K</span>: es el Kernel, una función que define la forma y la distribución de la influencia (peso) que se asocian a cada observación. En los ejemplos anteriores se ha utilizado como kernel la distribución normal.</p></li>
</ul>
<p><strong>Selección de Ancho de Banda</strong></p>
<p>El ancho de banda es crucial a la hora de estimar una función densidad mediante el método KDE. Si su valor es muy bajo, se genera overfitting y la función resultante estará demasiado influenciada por el “ruido” de los datos. Si su valor es muy elevado, la función resultante no será capaz de aprender la distribución subyacente.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/banda_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Tipos de Distribuciones de acuerdo a valor de ancho de Banda</figcaption>
</figure>
</div>
<p><em>Reglas empíricas</em></p>
<ul>
<li><p>Scott’s rule: <span class="math inline">h≈1.06 \cdot \hat{\sigma}n^{−1/5}</span></p></li>
<li><p>Silverman’s rule: <span class="math inline">h=0.9\cdot min(\hat{\sigma},IQR/1.35)n^{−1/5}</span></p></li>
</ul>
<p>Si bien estos métodos son muy rápidos, tienen el limitante de funcionar bien solo cuando la función de densidad real es aproximadamente normal.</p>
<p>También se puede usar validación cruzada que requiere de mayor tiempo de computación pero es útil para cualquier tipo de distribución. Validación cruzada es la opción disponible en Scikit learn, utilizando como métrica de comparación en <em>log-likelihood</em>.</p>
<p>Es importante destacar que, cuando se dispone de pocos datos, conviene utilizar <em>one leave out crossvalidation</em>.</p>
<p><strong>Tipos de kernel</strong></p>
<p>El kernel es la función que determina cómo se distribuye la influencia de cada observación, por lo tanto, puede tener un impacto notable en la estimación de la función de densidad resultante. Aunque en la gran mayoría de casos se emplea un kernel gaussiano (distribución normal), existen otras posibilidades.</p>
<ul>
<li><p><strong>Gaussian</strong>: asigna los pesos siguiendo la distribución normal con una desviación estándar equivalente al ancho de banda.</p></li>
<li><p><strong>Epanechnikov</strong>: las observaciones que están a una distancia entre 0 y h tienen un peso entre <span class="math inline">\frac{3}{4}</span> y 0 con disminución cuadrática. Toda observación fuera de este rango tiene pero 0.</p></li>
<li><p><strong>Tophat</strong>: Asigna el mismo peso a todas las observaciones que estén dentro del ancho de banda.</p></li>
<li><p><strong>Exponential</strong>: el peso decae de forma exponencial.</p></li>
<li><p><strong>Linear</strong>: el peso decae de forma lineal dentro del ancho de banda. Más allá de este el pero es 0.</p></li>
<li><p><strong>Cosine</strong>: el peso dentro del ancho de banda es proporcional al coseno.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/tipos_kernel_kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Algunos tipos de Kernel más utilizados</figcaption>
</figure>
</div>
<!-- _TO-DO: Agregar formulas de cada Kernel_ -->
</section>
<section id="kde-aproximación-espacial" class="level3 page-columns page-full" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="kde-aproximación-espacial"><span class="header-section-number">4.2.3</span> KDE aproximación espacial</h3>
<p>Para entender el concepto KDE se presentó anteriormente en su forma básica correspondiente a una distribución univariada, como por ejemplo la distribución (bimodal) siguiente:</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/d-bimodal-kde.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Distribución Univariada</figcaption>
</figure>
</div>
<p>Para aplicar los KDE a casos espaciales, se tiene que entender que las variables aleatorias antes señaladas, ahora van a corresponder a eventos o condiciones físicas que ocurren en el espacio, por ende bajo un sistema de coordenadas, por lo cual el eje de coordenadas <span class="math inline">x</span> e <span class="math inline">y</span> que también intervienen como nuevas dimensiones, entonces los que se predente estimar una distribución multivariante.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/Density- map_point-map.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">De puentos espaciales a Mapa de Densidad.</figcaption>
</figure>
</div>
<p>Una de las aplicaciones más comunas es de el análisis criminal, ya que los algunas categorías delitos coproducen bajo ciertas condiciones espaciales.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/lc_delitos_dom.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption class="margin-caption">Ejemplo de Kernel Density Estimation de Delitos en Domicilios en la Comuna de Las Condes</figcaption>
</figure>
</div>
<p>Entonces para el caso espacial lo que se prentende identificar patrones de cluster basándose en proximidad espacial</p>
<p>Los elementos del KDE Univariado tambien están presentes en el caso espacial como por ejemplo en ancho debanda como se observa a continuación.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/kde_spatial.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">KDE Espacial con diferentes tipos de Ancho de Banda.</figcaption>
</figure>
</div>
<!-- ### Kernel Density Estimation en delitos Violentos -->
<!-- Existe una gama importante de métodos de interpolación como el Kriging, las superficies de tendencia, el inverso de la distancia y los modelos de regresión local, (Anselin, 1992; Clevelend at al. 1993, Venables & Ripley, 1997) los cuales requieren en su mayoría que los puntos de muestreo/entrada asuman valores heterogéneos diferentes de cero. -->
<!-- Considerando que los dato con que se trabajará son eventos delictivos, por ensde no se hace muetreo  de la información, el universo está dado por la totalidad de los eventos registrados, adicionalmente cada punto representa un evento particular. -->
<!-- Como no en toda la superficie de una zona de estudio han sucedido delitos, pero existe una probabilidad de que ocurran, la estimación de densidad de kernel sirve para calcular esa probabilidad (Smith & Bruce 2008, 60-64) de modo que la interpolación produce "superficies de riesgo". -->
<!-- ![Suma de funciones normales de Kernel de 5 Puntos](images/kde_exp.png){width=50%} -->
<!-- *Fuente: Estimación de densidad de Kernel. Adaptado de Wilson, R. y Eck, J. (2005: 27).* -->
<!-- Cargar Librerías -->
<!-- ```{r} -->
<!-- library(rgdal) -->
<!-- library(sf) -->
<!-- library(dplyr) -->
<!-- library(rgeos) -->
<!-- library(raster) -->
<!-- library(spatstat) -->
<!-- library(spdep) -->
<!-- library(mapview) -->
<!-- library(viridis) -->
<!-- library(ggplot2) -->
<!-- ``` -->
<!-- Lectura de casos violencia (Las Condes, anonimizados) -->
<!-- ```{r} -->
<!-- violencia_df <- readRDS(file = "data/delitos/casos_violencia.rds") -->
<!-- head(violencia_df) -->
<!-- ``` -->
<!-- Transformar a Objeto Espacial -->
<!-- ```{r} -->
<!-- violencia <-  st_as_sf(x = violencia_df,  -->
<!--                           coords = c("x", "y"), crs = 32719) -->
<!-- ggplot() + -->
<!--   geom_sf(data = violencia,  color =  "red",  -->
<!--           alpha=0.8,  size= 0.1)+ -->
<!--   ggtitle("Delitos Violentos en Las Condes") + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- **KDE con Raster** -->
<!-- Calcular KDE con Función cuartica o esférica (`quartic`) -->
<!-- Supone una distribución relativamente uniforme que al llegar a cierto umbral decae sin suavidad: -->
<!--  ![Kernel  cuártica o esférica](images/func_quartic.png){width=70%} -->
<!-- Definir Parámetros -->
<!-- ```{r} -->
<!-- library(SpatialKDE) -->
<!-- #Definirán Parámemetros de Estudio -->
<!-- cell_size <- 100 # Tamaño de Celda -->
<!-- band_width <- 500 #  Parámetro de Suavisado (denominada ventana o h) -->
<!-- ``` -->
<!-- Crear Raster Vacío -->
<!-- ```{r} -->
<!-- raster_violencia <- violencia %>%  -->
<!--   create_raster(cell_size = cell_size, side_offset = band_width) -->
<!-- ``` -->
<!-- Crear Kernel raster -->
<!-- ```{r} -->
<!-- kde_raster <- violencia %>%  -->
<!--   kde(band_width = band_width, kernel = "quartic", grid = raster_violencia) -->
<!-- ``` -->
<!-- Histograma de valores de Densidad -->
<!-- ```{r} -->
<!-- hist(kde_raster, col="springgreen4", main="Histograma KDE", -->
<!--   ylab="Número de Pixeles", xlab="valor KDE") -->
<!-- # writeRaster(kde_raster, "data/delitos/kde_delvio_LC.tif") -->
<!-- ``` -->
<!-- Visualizar Raster KDE con ggplot -->
<!-- ```{r} -->
<!-- # rastero to df (na omit) -->
<!-- kde_raster_df <- raster::as.data.frame(kde_raster, xy = TRUE) %>% na.omit() -->
<!-- umbral <- 1 -->
<!-- kde_raster_df <- kde_raster_df %>%  -->
<!--   mutate(layer = ifelse(layer < umbral, NA, layer)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- ggplot() + -->
<!--   geom_raster(data = kde_raster_df %>% na.omit() ,  -->
<!--              aes(x = x, y = y,  -->
<!--                   fill = layer)) +  -->
<!--   scale_fill_gradientn(name = "KDE",  -->
<!--                        colors = (viridis::magma(100)), na.value = NA)+ -->
<!--   coord_fixed()+ -->
<!--   ggtitle(paste0("KDE Raster de Delitos") ) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- Función Para filtrar Raster (solo para tener en cuenta) -->
<!-- ```{r eval =FALSE} -->
<!-- na_menor <- function(x){ -->
<!--   x[x < 10] <- NA -->
<!--   return(x) -->
<!-- } -->
<!-- kde_raster2 <- calc(kde_raster, fun = na_menor) -->
<!-- ``` -->
<!-- KDE a  Indicador Territorial -->
<!-- Leer manzanas del Censo -->
<!-- ```{r} -->
<!-- mi_comuna <-  "LAS CONDES" -->
<!-- mz_comuna <- readRDS("data/censo/manzanas.rds") %>%  -->
<!--   filter(NOM_COM == mi_comuna) %>%  -->
<!--   st_transform(32719) -->
<!-- ``` -->
<!-- Cálculo de Indicador de Delitos Violentos -->
<!-- ```{r} -->
<!-- library(exactextractr) -->
<!-- mz_comuna  <- mz_comuna %>%  -->
<!--   mutate(idelv = exact_extract(kde_raster,y = ., 'mean',  -->
<!--                                progress = FALSE)) -->
<!-- # saveRDS(mz_comuna, "data/delitos/idel_violentos_LC.rds") -->
<!-- ``` -->
<!-- Visualización del Indicador -->
<!-- ```{r} -->
<!-- # pal_idelv<- colorRampPalette(c("white",  "red"))( 100 ) -->
<!-- ggplot() + -->
<!--   geom_sf(data = mz_comuna, aes(fill = idelv), color ="gray80",  -->
<!--           alpha=0.8,  size= 0.1)+ -->
<!--   # scale_fill_gradientn(colors = pal_idelv)+ -->
<!--   scale_fill_distiller(palette= "Reds", direction = 1)+ -->
<!--   ggtitle("Indicador de Delitos Violentos") + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
</section>
</section>
<section id="interpolación-inverso-a-distancia-ponderada-idw" class="level2 page-columns page-full" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="interpolación-inverso-a-distancia-ponderada-idw"><span class="header-section-number">4.3</span> Interpolación Inverso a Distancia Ponderada IDW</h2>
<section id="definiciones" class="level3 page-columns page-full" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="definiciones"><span class="header-section-number">4.3.1</span> Definiciones</h3>
<p>Este tipo de interpolación, determina los valores de celda a través de una combinación ponderada linealmente de un conjunto de datos de puntos de muestra. Esto significa que los puntos de muestreo se ponderan de tal manera que la influencia de un punto frente a otro, disminuye con la distancia.</p>
<p>Cuanto más cerca está un punto del centro de la celda que se está estimando, más influencia o peso tendrá en el proceso de cálculo del promedio.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/values_idw.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Estimación de valores por interpolación de inverso a la distancia</figcaption>
</figure>
</div>
<p>los puntos rojos tienen valores de elevación conocidos. Los otros puntos serán interpolados. Si desea medir el punto púrpura, puede configurar su interpolación para que tome un número fijo o variable de puntos. En este ejemplo, utiliza un número fijo de 3 puntos de 3 y utiliza los tres puntos más cercanos.</p>
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><img src="images/exp_idw.png" class="img-fluid figure-img"></p>
<figcaption class="margin-caption">Descripción gráfica de los resultados de interpolación</figcaption>
</figure>
</div>
<p>Dado que la IDW es un promedio de distancia ponderada, el promedio no puede ser mayor que la entrada máxima o inferior que la entrada mínima. Por lo tanto, no puede crear crestas o valles si estos extremos aún no se han muestreado (Watson y Philip 1985).</p>
<!-- ### Usos prácticos -->
<!-- **Pasos** -->
<!-- * Definición de Área de Estudio -->
<!-- * Interpolación de información Comercio y Oficina -->
<!-- * Crear Indicador de Atractor de Comercios y Oficina -->
<!-- **Desarrollo** -->
<!-- Definición de Área de Estudio -->
<!-- Para efectos de este ejemplo práctico se utilizará el área urbana de la comuna de Las Condes. -->
<!-- ```{r} -->
<!-- mi_comuna <-  "LAS CONDES" -->
<!-- zonas <-  readRDS("data/censo/zonas_urb_consolidadas.rds") -->
<!-- comuna <-  zonas %>% filter(NOM_COMUNA == mi_comuna) -->
<!-- ``` -->
<!-- Visualizaciíon  de Área de Estudio -->
<!-- ```{r} -->
<!-- ggplot() + -->
<!--   geom_sf(data = comuna, aes(fill = ESC_JH), color =NA,  -->
<!--           alpha=0.8,  size= 0.1)+ -->
<!--   scale_fill_distiller(palette= "YlGnBu", direction = 1)+ -->
<!--   ggtitle("Población Zonas Censales - Urbano" ) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- Obtener el Borde comunal -->
<!-- ```{r} -->
<!-- comuna_border <- comuna %>% st_union() -->
<!-- ``` -->
<!-- ```{r} -->
<!-- ggplot() + -->
<!--   geom_sf(data = comuna_border, fill = "gray90", color ="gray30",  -->
<!--           alpha=0.8,  size= 0.8)+ -->
<!--   ggtitle("Borde Zonas Censales - Urbano" ) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- **Imputar información SII a zonas censales** -->
<!-- Lectura de datos de SII (puntos) -->
<!-- ```{r} -->
<!-- sii_ptos <- st_read("data/sii/urbes.shp", quiet = T) -->
<!-- ``` -->
<!-- Selección de Comuna -->
<!-- ```{r} -->
<!-- comuna_sii <-  sii_ptos %>% filter(n_com == mi_comuna) %>%  -->
<!--   st_transform(32719) -->
<!-- # comuna_sii -->
<!-- ``` -->
<!-- Visualización de los Puntos del SII -->
<!-- ```{r} -->
<!-- ggplot() + -->
<!--   geom_sf(data = comuna_sii,  color ="orange",  -->
<!--           alpha=0.8,  size= 0.5)+ -->
<!--   ggtitle("Predios SII - Urbano" ) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- **Interpolación de Inverso a la Distancia ponderada por Atractores (SII)** -->
<!-- Definción ventana de trabajo -->
<!-- ```{r} -->
<!-- crs_utm <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs" # 32719 -->
<!-- suppressMessages(library(raster)) -->
<!-- # grilla desde mancha comuna -->
<!-- urbano_utm <- st_transform(comuna, crs_utm) -->
<!-- urbano_sp <- as(urbano_utm, "Spatial") -->
<!-- ext <- raster::extent(urbano_sp) -->
<!-- x_min <- ext[1] - 100 -->
<!-- x_max <- ext[2] + 100 -->
<!-- y_min <- ext[3] - 100 -->
<!-- y_max <- ext[4] + 100 -->
<!-- ``` -->
<!-- Definción grilla de interpolación** -->
<!-- ```{r fig.align='center', fig.width=7} -->
<!-- ## Definir espaciado de interpolacion -->
<!-- grd=expand.grid(x = seq(from = x_min,to = x_max, by=100), -->
<!--                 y = seq(from = y_min,to = y_max, by=100)) -->
<!-- coordinates(grd)=~x+y -->
<!-- gridded(grd)=T -->
<!-- proj4string(grd)= "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs" # 32719 -->
<!-- plot(grd) -->
<!-- ``` -->
<!-- Cálculo de Interpolación de Inverso a la Distancia -->
<!-- ```{r} -->
<!-- # Decsar Valores NA -->
<!-- sii_sp <- comuna_sii%>% -->
<!--   st_transform(crs_utm) %>%  -->
<!--   filter(!is.na(atractor))%>% -->
<!--   as("Spatial") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- interp_sii=gstat::idw(formula = sii_sp@data$atractor ~ 1,  -->
<!--                  locations = sii_sp,  -->
<!--                  newdata = grd, idp = 1, -->
<!--                  na.action = na.omit, nmax = 4) -->
<!-- ``` -->
<!-- Ajustes del Resultado -->
<!-- * Asiganar CRS -->
<!-- * Tranformar valores  NA a 0 -->
<!-- * Transformar raster y cortar por contorno urbano -->
<!-- ```{r} -->
<!-- proj4string(interp_sii) = proj4string(sii_sp) # Asignar crs -->
<!-- interp_sii@data[is.na(interp_sii@data)] = 0 # trasnformar los valores 0 en NA -->
<!-- interp_sii <- mask(raster(interp_sii, values = T), urbano_sp) # cortar por borde comunal -->
<!-- ``` -->
<!-- Visualización -->
<!-- ```{r} -->
<!-- interp_sii_df <- raster::as.data.frame(interp_sii, xy = TRUE) %>% na.omit() -->
<!-- ggplot() + -->
<!--   geom_raster(data = interp_sii_df ,  -->
<!--              aes(x = x, y = y,  -->
<!--                   fill = var1.pred)) +  -->
<!--   scale_fill_gradientn(name = "IDW",  -->
<!--                        colors = (viridis::viridis(100)), na.value = NA)+ -->
<!--   coord_fixed()+ -->
<!--   ggtitle(paste0("IDW Atractores de Comercio y Oficina") ) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
<!-- Cálculo de Indicador  de Atractor IDW -->
<!-- ```{r} -->
<!-- mz_comuna  <- mz_comuna %>%  -->
<!--   mutate(atractor_sii = exact_extract(interp_sii,y = ., 'mean',  -->
<!--                                progress = FALSE)) -->
<!-- ``` -->
<!-- Visualización del Indicador `atractor_sii` -->
<!-- ```{r} -->
<!-- ggplot() + -->
<!--   geom_sf(data = mz_comuna, aes(fill = atractor_sii), color =NA,  -->
<!--           alpha=0.8,  size= 0.1)+ -->
<!--   scale_fill_viridis_c()+ -->
<!--   ggtitle("Indicador de Atractor de Comercio y Oficinas") + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray80"),  -->
<!--         panel.grid.minor = element_line(colour = "gray80")) -->
<!-- ``` -->
</section>
</section>
<section id="referencias" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="referencias"><span class="header-section-number">4.4</span> Referencias</h2>
<ul>
<li><p><a href="https://www.cienciadedatos.net/documentos/pystats02-kernel-density-estimation-kde-python.html">Ajuste de distribuciones con kernel density estimation y Python</a></p></li>
<li><p><a href="https://www.mdpi.com/2079-9292/9/5/837/htm">Role of Big Data in the Development of Smart City by Analyzing the Density of Residents in Shanghai</a></p></li>
<li><p><a href="https://www.mdpi.com/2220-9964/8/12/544/htm">How Is the Confidentiality of Crime Locations Affected by Parameters in Kernel Density Estimation?</a></p></li>
<li><p><a href="https://pro.arcgis.com/es/pro-app/latest/tool-reference/spatial-analyst/idw.htm">IDW (Spatial Analyst)</a></p></li>
<li><p><a href="http://ru.iiec.unam.mx/4646/1/4-114-Navarrete-Lopez.pdf">IMPORTANCIA DE LOS ESPACIOS COMUNES: UNA ADAPTACIÓN DE LA TÉCNICA DE INTERPOLACIÓN ESPACIAL INVERSE DISTANCE WEIGHTED (IDW) EN LA PREDICCIÓN DE DATOS SOCIOECONÓMICOS AUSENTES</a></p></li>
</ul>
<!-- legacy -->
<!-- #### KDE con Polígonos (grilla regular) -->
<!-- Crear Grilla -->
<!-- ```{r} -->
<!-- # Crear una grilla de Delitos de Violencia -->
<!-- grid_violencia <- violencia %>%  -->
<!--   create_grid_rectangular(cell_size = cell_size, side_offset = band_width) -->
<!-- plot(grid_violencia) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # Calcular kde quartic -->
<!-- kde_quartic <- violencia %>%  -->
<!--   kde(band_width = band_width, kernel = "quartic", grid = grid_violencia) -->
<!-- # as.numeric(object.size(kde_quartic))/1e6 # calcular peso del resultado -->
<!-- ``` -->
<!-- Visualziar Resultados de KDE `quartic` -->
<!-- ```{r} -->
<!-- kde_q <- ggplot(data = kde_quartic) + -->
<!--   geom_sf(aes(fill= kde_value), color = NA, alpha = 0.9)+  -->
<!--   scale_fill_gradientn(colors = (viridis::magma(100)), na.value = NA)+ -->
<!--   # scale_color_viridis()+ -->
<!--   ggtitle(paste0("Kernel Density Estimation (Kernel quartic)")) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray90"),  -->
<!--         panel.grid.minor = element_line(colour = "gray90")) -->
<!-- kde_q -->
<!-- ``` -->
<!-- ```{r} -->
<!-- # reemplazar valores 0 po NA -->
<!-- umbral <- 10 -->
<!-- kde_quartic <- kde_quartic %>%  -->
<!--   mutate(kde_value = ifelse(kde_value <= umbral, NA, kde_value)) -->
<!-- kde_q <- ggplot(data = kde_quartic) + -->
<!--   geom_sf(aes(fill= kde_value), color = NA, alpha = 0.9)+  -->
<!--   scale_fill_gradientn(colors = (viridis::magma(100)), na.value = NA)+ -->
<!--   # scale_color_viridis()+ -->
<!--   ggtitle(paste0("Kernel Density Estimation (Kernel quartic)")) + -->
<!--   theme_bw() + -->
<!--   theme(panel.grid.major = element_line(colour = "gray90"),  -->
<!--         panel.grid.minor = element_line(colour = "gray90")) -->
<!-- kde_q -->
<!-- ``` -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./analisis_esp.html" class="pagination-link" aria-label="Análisis Espacial">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Análisis Espacial</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./construccion_inds.html" class="pagination-link" aria-label="Construcción de Indicadores Territoriales">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Construcción de Indicadores Territoriales</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Denis Berroeta</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>